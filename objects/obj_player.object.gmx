<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_stand</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Define variables

//Constant
grav = 1;
MOVE_SPD = 2;       //walking speed
VSP_MAX = 8;       //maximum falling speed
JUMP_SPD = 8;      //initial jumping vsp
JUMP_DECEL = 1;     //deceleration after jumping
SPR_H = 30; //player sprite height, used to calculate collision on player foot

//variable
hsp = 0;
vsp = 0;
jumping=0;  
standing=1;
state = 0; //0=Standing, 1=Walking, 2 = Jumping, 3=Falling
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite control

if(vsp!=0){
    sprite_index = spr_player_jump;
}else{
    if(hsp==0){
        sprite_index = spr_player_stand;
        image_index  = 0;
        image_speed = 0;
    }else{
        sprite_index = spr_player_walk;
        image_speed = 0.25;
    }
}

if(hsp != 0){
    image_xscale = sign(hsp);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input Control

//------------------------------
//      INPUT CONTROL
//------------------------------

//Dash control

//Get the player's input

key_right = keyboard_check(vk_right);   //1 if pressing right, 0 otherwise
key_left = -keyboard_check(vk_left);    //-1 if pressing left, 0 otherwise
key_jump = keyboard_check_pressed(vk_space);
//key_float = keyboard_check(vk_space);
//key_left=-1;
//Horizontal movement control
move = key_left+key_right;  //if pressing both right and left, movement cancels out




/*
if(move == 1) {                 //pressing RIGHT
    
    if(hsp &lt; 0){                //if heading opposite, skid
        hsp += SKID_DECEL;      
        skidding = 1;
        if(hsp &gt; 0) hsp = 0;
    } else {                    //else, either walk or dash
        if (place_meeting(x,y+1,obj_solid))     //if on the ground, check if player is triggering dash
        {
            if(alarm[1]&gt;0 and alarm[1] &lt; DASH_TIMER){
                if(keyboard_check_pressed(vk_right)) 
                    dashing=1
                    
            }
        }
        
        if (dashing) hsp = DASH_SPD;
        else hsp = WALK_SPD;
    }
    alarm[1] = DASH_TIMER;      //set dash alarm
} else if (move == -1){         //pressing LEFT
   
    if(hsp &gt; 0){                //if heading opposite, skid
        hsp -= SKID_DECEL;
        skidding = 1;
        if(hsp &lt; 0) hsp = 0;    
    } else {                    //else, walk or dash
        if (place_meeting(x,y+1,obj_solid))     //if on the ground, check if player is triggering dash
        {
            if(alarm[1]&gt;0 and alarm[1] &lt; DASH_TIMER){
                if(keyboard_check_pressed(vk_left)) 
                    dashing=1
            }
        }
        if (dashing) hsp = -DASH_SPD;
        else hsp = -WALK_SPD;
        
    }
    alarm[1] = DASH_TIMER;
} else {                        //not pressing anything
    if(hsp &gt; 0) {               //decelerate Kirby         
        hsp -= DECEL;
        if(hsp &lt; 0) hsp = 0;
    } else if (hsp &lt; 0) {
        hsp += DECEL;
        if(hsp &gt; 0) hsp = 0;
    }
       
}

//Vertical gravity
if (!place_meeting(x,y+1,obj_solid))
{
    if(floating){
        if(vsp &lt; VSPEEDMAX_FLOAT) vsp += float_grav;
    } else if (vsp &lt; VSPEEDMAX) vsp += grav;
}
//Float Control
if(((jumping or falling) and key_jump) or (floating and key_float)){
    jumping = 0;
    floating = 1;
    vsp = -FLOAT_SPD;
    dashing = 0;
}


//Jump Control
if (place_meeting(x,y+1,obj_solid))
{
    if(!floating and key_jump) {
        vsp = -JUMP_SPD;
        jumping = 1;   
    } else {
        jumping = 0;
        floating = 0;
    }
}
if(vsp &lt; 0 and not keyboard_check(vk_space)){
    vsp *= JUMP_DECEL;
}
*/

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement, gravity, jump control

//Horizontal movement control
hsp = move*MOVE_SPD;

//Gravity control
vsp = min(vsp+grav,VSP_MAX);
if (place_meeting(x,y+1,obj_solid) or position_meeting(x,y+SPR_H+1,obj_slope)) //if standing on ground
{
    vsp = 0;         
}

//Jump Control
if (place_meeting(x,y+1,obj_solid) or position_meeting(x,y+SPR_H+1,obj_slope)) //if standing on ground
{
    if(key_jump) {
        vsp = -JUMP_SPD;
        jumping = 1;   
    } else {
        jumping = 0;
    }
}
if(jumping and vsp &lt; 0 and not keyboard_check(vk_space)){
    vsp = round(vsp/JUMP_DECEL);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Solid Collision + Slope Cllision

//horizontal collision
if(hsp != 0 and place_meeting(x+hsp,y,obj_solid)){      //if moving and colliding with solid in direction moving
        
        while(!place_meeting(x+sign(hsp),y,obj_solid)){ //move in 1 pixel until contact
            x += sign(hsp);
        }
        hsp = 0;
    
    
}

//vertical collision
if(vsp != 0 and place_meeting(x,y+vsp,obj_solid)){      //if moving and colliding with solid in direction moving
    if(vsp &lt; 0 and !place_meeting(x+2,y+vsp,obj_solid)){        //snap to wall when falling/rising very near to vertical walls
        x += 2;
    } else if(vsp &lt; 0 and !place_meeting(x-2,y+vsp,obj_solid)){
        x -= 2;
    } else {
        while(!place_meeting(x,y+sign(vsp),obj_solid)){ //move in 1 pixel until contact
            y += sign(vsp);
        }
        vsp = 0;
    }
          

}


//Diagonal
if(hsp!=0 and vsp!=0 and place_meeting(x+hsp, y+vsp, obj_solid)){   //if moving and colliding with solid in direction moving
    
    while(!place_meeting(x+sign(hsp),y,obj_solid)){         //move in 1 pixel until contact
        x += sign(hsp);
        y += sign(vsp);
    }
    
    while(place_meeting(x, y + sign(vsp), obj_solid))       //snap to wall when moving diagonally when falling/rising very near to vertical walls
    {
        x -= sign(hsp);
    }
    hsp = 0;
}


//--------------------------------
//  SLOPE COLLISION
//--------------------------------
//  All slope objects are inherited from obj_slope which is sued to test collision

//slope vertical collision
if(vsp!= 0 and position_meeting(x,y+SPR_H+vsp,obj_slope)){      //if moving and colliding with slope in direction moving
     while(!position_meeting(x,y+SPR_H+sign(vsp),obj_slope)){   //move in 1 pixel until contact
         y += sign(vsp);
     }
     vsp = 0;
}

//walking on slope collision
//First, check if player is going up slope or not
//This is done by checking that next position horizontally is still on slope, if yes it means player is going up on the slope
slope_up_inst = instance_position(floor(x+hsp),y+SPR_H,obj_slope);  //check if next position is still on slope
if (slope_up_inst != noone){    //if yes it will be that slope object id
    
    if(slope_up_inst.SLOPE_RATIO == 0){     //if it's "obj_slope_end" then it will always push player up to its top
        rel_x = 16;         
    } else {
        //calculate relative x position of player from the slope x (very left)
        rel_x = floor(x+hsp) - slope_up_inst.x;     
        if(slope_up_inst.SLOPE_RATIO &lt; 0){  //if opposite slope direction invert the relative value
            rel_x = 15-rel_x;
        }
    }
    //show_debug_message(string(slope_up_inst)+" "+string(rel_x));
    //set player at position relative to that slope y position using rel_x as a offset
    newy = slope_up_inst.y - rel_x*2 + 1;
    
    y = floor(newy);
    
} else {
    //If not going up, check if he is going down on slope or not
    //Check first if player is standing on slope, then check if next position player would be if he is going down on slope is still on slope
    standing_slope = instance_position(x,y+SPR_H+1,obj_slope);  //check if standing on slope
    if(standing_slope != noone){
        slope_down_inst = instance_position(floor(x+hsp),floor(y+SPR_H+abs(hsp)+1),obj_slope);  //check if still on slope at position he would be if he goes down on slope
        if(slope_down_inst != noone){       //if yes it will be that slope object id
            
            if(slope_down_inst.SLOPE_RATIO == 0){  //if it's "obj_slope_end" then it will always push player up to its top
                rel_x = 16;
            } else {
                //calculate relative x position of player from the slope x (very left)
                rel_x = floor(x+hsp) - slope_down_inst.x;
                if(slope_down_inst.SLOPE_RATIO &lt; 0){
                    rel_x = 15-rel_x;   //if opposite slope direction invert the relative value
                }
            }
            
            //show_debug_message(string(slope_down_inst)+" "+string(rel_x));
            //set player at position relative to that slope y position using rel_x as a offset
            newy = slope_down_inst.y - rel_x*2 + 1;
            y = floor(newy);
            
        }
    }
    
}

//update player to his next position
x = floor(x+hsp);
y = floor(y+vsp);



//UNUSED
/*
//Horizontal collision
if (hsp!=0){
    if (place_meeting(x+hsp,y,obj_solid)){      //if slope
        y_offset = 0;
        while(y_offset &lt;= abs(hsp) and place_meeting(x+hsp,y-y_offset,obj_solid)){
            y_offset++;
        }
        if(place_meeting(x+hsp,y-y_offset,obj_solid)){
            while(!place_meeting(x+sign(hsp),y,obj_solid)){
                x += sign(hsp);
            } 
            image_xscale = sign(hsp); //special case, kirby is in a 1x1 hole
            hsp = 0;
            dashing = 0;
            
        } else {
            y -= y_offset;
        }   
    }
    else {      //normal floor
        y_offset = 0;
        while(!place_meeting(x+hsp,y+1+y_offset,obj_solid) and y_offset &lt;= abs(hsp)){
            y_offset++;
        }
        if(!place_meeting(x+hsp,y+y_offset,obj_solid)){
            y += y_offset;
        }  
    }
}

//Vertical collision
if (vsp!=0 and place_meeting(x,y+vsp,obj_solid))        //if moving 
{
    if(vsp &lt; 0 and !place_meeting(x+2,y+vsp,obj_solid)){        //snap to wall when falling/rising very near to vertical walls
        x += 2;
    } else if(vsp &lt; 0 and !place_meeting(x-2,y+vsp,obj_solid)){
        x -= 2;
    } else {        //falling/rising normally
        while(!place_meeting(x,y+sign(vsp),obj_solid))
        {
        y += sign(vsp);
        }
        vsp = 0;
    } 
    
}
*/
//diagonal collision
/*
if(hsp != 0 and vsp != 0 and place_meeting(x+hsp, y+vsp, obj_solid))
{
    while(!place_meeting(x+sign(hsp), y + sign(vsp), obj_solid))        //if not hitting a wall
    {
        x+= sign(hsp);
        y+= sign(vsp);
    }
    while(place_meeting(x, y + sign(vsp), obj_solid))       //snap to wall when moving diagonally when falling/rising very near to vertical walls
    {
        x -= sign(hsp);
    }
    hsp = 0;
}
*/

//slope horizontal collision
/*slope = instance_place(x,y+1,obj_slope);
if(hsp != 0 and slope != noone)
{
    //Slope collision handler
    y -= (hsp/slope.ratio);
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!instance_exists(obj_camera)){
instance_create(0,0,obj_camera)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
