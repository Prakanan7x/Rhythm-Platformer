<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>grav = 2;
hsp = 0;
vsp = 0;
MOVE_SPD = 4;
VSP_MAX = 8;
JUMP_SPD = 16;
JUMP_DECEL = 0.5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input Control

//------------------------------
//      INPUT CONTROL
//------------------------------

//Dash control

//Get the player's input

key_right = keyboard_check(vk_right);   //1 if pressing right, 0 otherwise
key_left = -keyboard_check(vk_left);    //-1 if pressing left, 0 otherwise
key_jump = keyboard_check_pressed(vk_space);
//key_float = keyboard_check(vk_space);
//key_left=-1;
//Horizontal movement control
move = key_left+key_right;  //if pressing both right and left, movement cancels out

hsp = move*MOVE_SPD;

vsp = min(vsp+grav,VSP_MAX);

//Jump Control
jumping = 0;
if (place_meeting(x,y+1,obj_solid) or position_meeting(x,y+30+1,obj_slope))
{
    if(key_jump) {
        vsp = -JUMP_SPD;
        jumping = 1;   
    } else {
        jumping = 0;
    }
}
if(vsp &lt; 0 and not keyboard_check(vk_space)){
    vsp *= JUMP_DECEL;
}

/*
if(move == 1) {                 //pressing RIGHT
    
    if(hsp &lt; 0){                //if heading opposite, skid
        hsp += SKID_DECEL;      
        skidding = 1;
        if(hsp &gt; 0) hsp = 0;
    } else {                    //else, either walk or dash
        if (place_meeting(x,y+1,obj_solid))     //if on the ground, check if player is triggering dash
        {
            if(alarm[1]&gt;0 and alarm[1] &lt; DASH_TIMER){
                if(keyboard_check_pressed(vk_right)) 
                    dashing=1
                    
            }
        }
        
        if (dashing) hsp = DASH_SPD;
        else hsp = WALK_SPD;
    }
    alarm[1] = DASH_TIMER;      //set dash alarm
} else if (move == -1){         //pressing LEFT
   
    if(hsp &gt; 0){                //if heading opposite, skid
        hsp -= SKID_DECEL;
        skidding = 1;
        if(hsp &lt; 0) hsp = 0;    
    } else {                    //else, walk or dash
        if (place_meeting(x,y+1,obj_solid))     //if on the ground, check if player is triggering dash
        {
            if(alarm[1]&gt;0 and alarm[1] &lt; DASH_TIMER){
                if(keyboard_check_pressed(vk_left)) 
                    dashing=1
            }
        }
        if (dashing) hsp = -DASH_SPD;
        else hsp = -WALK_SPD;
        
    }
    alarm[1] = DASH_TIMER;
} else {                        //not pressing anything
    if(hsp &gt; 0) {               //decelerate Kirby         
        hsp -= DECEL;
        if(hsp &lt; 0) hsp = 0;
    } else if (hsp &lt; 0) {
        hsp += DECEL;
        if(hsp &gt; 0) hsp = 0;
    }
       
}

//Vertical gravity
if (!place_meeting(x,y+1,obj_solid))
{
    if(floating){
        if(vsp &lt; VSPEEDMAX_FLOAT) vsp += float_grav;
    } else if (vsp &lt; VSPEEDMAX) vsp += grav;
}
//Float Control
if(((jumping or falling) and key_jump) or (floating and key_float)){
    jumping = 0;
    floating = 1;
    vsp = -FLOAT_SPD;
    dashing = 0;
}


//Jump Control
if (place_meeting(x,y+1,obj_solid))
{
    if(!floating and key_jump) {
        vsp = -JUMP_SPD;
        jumping = 1;   
    } else {
        jumping = 0;
        floating = 0;
    }
}
if(vsp &lt; 0 and not keyboard_check(vk_space)){
    vsp *= JUMP_DECEL;
}
*/

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collision





if(hsp != 0 and place_meeting(x+hsp,y,obj_solid)){
    
        while(!place_meeting(x+sign(hsp),y,obj_solid)){
            x += sign(hsp);
        }
        hsp = 0;
    
    
}

if(vsp != 0 and place_meeting(x,y+vsp,obj_solid)){
    if(vsp &lt; 0 and !place_meeting(x+2,y+vsp,obj_solid)){        //snap to wall when falling/rising very near to vertical walls
        x += 2;
    } else if(vsp &lt; 0 and !place_meeting(x-2,y+vsp,obj_solid)){
        x -= 2;
    } else {
        while(!place_meeting(x,y+sign(vsp),obj_solid)){
            y += sign(vsp);
        }
        vsp = 0;
    }
          

}


//Diagonal
if(hsp!=0 and vsp!=0 and place_meeting(x+hsp, y+vsp, obj_solid)){
    
    while(!place_meeting(x+sign(hsp),y,obj_solid)){
        x += sign(hsp);
        y += sign(vsp);
    }
    
    while(place_meeting(x, y + sign(vsp), obj_solid))       //snap to wall when moving diagonally when falling/rising very near to vertical walls
    {
        x -= sign(hsp);
    }
    hsp = 0;
}



//going up slope check
if(vsp!= 0 and position_meeting(x,y+30+vsp,obj_slope)){  
     while(!position_meeting(x,y+30+sign(vsp),obj_slope)){
         y += sign(vsp);
     }
     vsp = 0;
}
slope_up_inst = instance_position(floor(x+hsp),y+30,obj_slope);
if (slope_up_inst != noone){
    
    if(slope_up_inst.SLOPE_RATIO == 0){
        rel_x = 32;
    } else {
        rel_x = floor(x+hsp) - slope_up_inst.x;
        if(slope_up_inst.SLOPE_RATIO &lt; 0){
            rel_x = min(0,31-rel_x);
        }
    }
    
    show_debug_message(string(slope_up_inst)+" "+string(rel_x));
    

    newy = slope_up_inst.y - rel_x;
    
    y = floor(newy);
    vsp = 0;
} else {
    standing_slope = instance_position(x,y+30+1,obj_slope);
    if(standing_slope != noone){
        slope_down_inst = instance_position(floor(x+hsp),floor(y+30+abs(hsp)+1),obj_slope);
        if(slope_down_inst != noone and slope_down_inst.SLOPE_RATIO != 0){ 
            rel_x = floor(x+hsp) - slope_down_inst.x;
            if(slope_down_inst.SLOPE_RATIO &lt; 0){
                rel_x = min(0,31-rel_x);
            }
            show_debug_message(string(slope_down_inst)+" "+string(rel_x));
            
            newy = slope_down_inst.y - rel_x;
            y = floor(newy);
            vsp = 0; 
        }
    }
    
}

x = floor(x+hsp);
y = floor(y+vsp);


/*
//Horizontal collision
if (hsp!=0){
    if (place_meeting(x+hsp,y,obj_solid)){      //if slope
        y_offset = 0;
        while(y_offset &lt;= abs(hsp) and place_meeting(x+hsp,y-y_offset,obj_solid)){
            y_offset++;
        }
        if(place_meeting(x+hsp,y-y_offset,obj_solid)){
            while(!place_meeting(x+sign(hsp),y,obj_solid)){
                x += sign(hsp);
            } 
            image_xscale = sign(hsp); //special case, kirby is in a 1x1 hole
            hsp = 0;
            dashing = 0;
            
        } else {
            y -= y_offset;
        }   
    }
    else {      //normal floor
        y_offset = 0;
        while(!place_meeting(x+hsp,y+1+y_offset,obj_solid) and y_offset &lt;= abs(hsp)){
            y_offset++;
        }
        if(!place_meeting(x+hsp,y+y_offset,obj_solid)){
            y += y_offset;
        }  
    }
}

//Vertical collision
if (vsp!=0 and place_meeting(x,y+vsp,obj_solid))        //if moving 
{
    if(vsp &lt; 0 and !place_meeting(x+2,y+vsp,obj_solid)){        //snap to wall when falling/rising very near to vertical walls
        x += 2;
    } else if(vsp &lt; 0 and !place_meeting(x-2,y+vsp,obj_solid)){
        x -= 2;
    } else {        //falling/rising normally
        while(!place_meeting(x,y+sign(vsp),obj_solid))
        {
        y += sign(vsp);
        }
        vsp = 0;
    } 
    
}
*/
//diagonal collision
/*
if(hsp != 0 and vsp != 0 and place_meeting(x+hsp, y+vsp, obj_solid))
{
    while(!place_meeting(x+sign(hsp), y + sign(vsp), obj_solid))        //if not hitting a wall
    {
        x+= sign(hsp);
        y+= sign(vsp);
    }
    while(place_meeting(x, y + sign(vsp), obj_solid))       //snap to wall when moving diagonally when falling/rising very near to vertical walls
    {
        x -= sign(hsp);
    }
    hsp = 0;
}
*/

//slope horizontal collision
/*slope = instance_place(x,y+1,obj_slope);
if(hsp != 0 and slope != noone)
{
    //Slope collision handler
    y -= (hsp/slope.ratio);
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
